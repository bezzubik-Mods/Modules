

from .. import loader, utils import logging import asyncio import re import json import aiohttp

from telethon import events

logger = logging.getLogger(name)

@loader.tds class MafiaAutoMod(loader.Module): """Автоматический игрок в мафию с поддержкой Gemini AI"""

strings = {"name": "MafiaAutoAI"}

def __init__(self):
    self._task = None
    self._running = False
    self._role = None
    self._game_state = "idle"
    self._last_message = None

    self.config = loader.ModuleConfig(
        "MafiaAutoAIConfig",
        [
            {"name": "bot", "type": str, "value": "@MafiaBakuBlackBot", "note": "Username of the mafia bot"},
            {"name": "join_cmd", "type": str, "value": "/join", "note": "Command to join game"},
            {"name": "start_cmd", "type": str, "value": "/start", "note": "Start command if required"},
            {"name": "vote_cmd", "type": str, "value": "/vote {}", "note": "Voting command template"},
            {"name": "night_action_cmd", "type": str, "value": "/kill {}", "note": "Mafia kill template"},
            {"name": "detective_cmd", "type": str, "value": "/check {}", "note": "Detective check template"},
            {"name": "doctor_cmd", "type": str, "value": "/save {}", "note": "Doctor save template"},
            {"name": "auto_vote", "type": bool, "value": True, "note": "Auto vote during day"},
            {"name": "use_gemini_ai", "type": bool, "value": True, "note": "Use Gemini AI for decision making"},
            {"name": "gemini_api_key", "type": str, "value": "", "note": "Your Google Gemini API key"},
            {"name": "ai_model", "type": str, "value": "gemini-1.5-pro", "note": "Model name for Gemini/other AI"},
            {"name": "message_patterns", "type": dict, "value": {
                "role_mafia": ["mafia", "маф"],
                "role_detective": ["detective", "детектив", "коп"],
                "role_doctor": ["doctor", "доктор", "врач"],
                "day_start": ["day", "день", "днём"],
                "night_start": ["night", "ночь", "ночью"],
            }, "note": "Patterns for text parsing"}
        ]
    )

async def client_ready(self, client, db):
    self._client = client
    self._db = db

async def _ask_gemini(self, prompt: str) -> str:
    """Запрос к Gemini API (или другой модели)"""
    if not self.config['use_gemini_ai'] or not self.config['gemini_api_key']:
        return ""

    url = f"https://generativelanguage.googleapis.com/v1beta/models/{self.config['ai_model']}:generateContent?key={self.config['gemini_api_key']}"
    headers = {"Content-Type": "application/json"}
    data = {
        "contents": [{"parts": [{"text": prompt}]}]
    }

    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=headers, data=json.dumps(data)) as resp:
                if resp.status != 200:
                    logger.error("Gemini API error: %s", await resp.text())
                    return ""
                res = await resp.json()
                text = res.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("text", "")
                return text.strip()
    except Exception as e:
        logger.exception("Gemini request failed: %s", e)
        return ""

async def _message_handler(self, event: events.NewMessage.Event):
    try:
        sender = await event.get_sender()
        if not sender or not hasattr(sender, 'username'):
            return
        if ('@' + (sender.username or '')).lower() != self.config['bot'].lower():
            return

        text = (event.message.message or '').lower()
        self._last_message = text
        patterns = self.config['message_patterns']

        if any(p in text for p in patterns.get('role_mafia', [])) and ('your role' in text or 'роль' in text):
            self._role = 'mafia'
        if any(p in text for p in patterns.get('role_detective', [])):
            self._role = 'detective'
        if any(p in text for p in patterns.get('role_doctor', [])):
            self._role = 'doctor'

        if any(p in text for p in patterns.get('night_start', [])):
            self._game_state = 'night'
            asyncio.create_task(self._night_action())

        if any(p in text for p in patterns.get('day_start', [])):
            self._game_state = 'day'
            if self.config['auto_vote']:
                asyncio.create_task(self._day_action())

    except Exception as e:
        logger.exception('Error in message handler: %s', e)

async def _night_action(self):
    await asyncio.sleep(1.5)
    try:
        target = ''
        if self.config['use_gemini_ai']:
            role = self._role or 'unknown'
            prompt = f"Ты играешь в мафию в Telegram. Твоя роль — {role}. Вот текущее сообщение:\n{self._last_message}\nРеши, кого выбрать целью, и верни только ник (например: @username)."
            ai_response = await self._ask_gemini(prompt)
            if ai_response:
                target = ai_response.split()[0]

        if not target:
            target = self._extract_target_from_text(self._last_message) or ''

        cmd = ''
        if self._role == 'mafia':
            cmd = self.config['night_action_cmd'].format(target)
        elif self._role == 'detective':
            cmd = self.config['detective_cmd'].format(target)
        elif self._role == 'doctor':
            me = (await self._client.get_me()).username or ''
            cmd = self.config['doctor_cmd'].format(me)

        await self._send_to_bot(cmd)
    except Exception as e:
        logger.exception('Night action failed: %s', e)

async def _day_action(self):
    await asyncio.sleep(1.0)
    try:
        target = ''
        if self.config['use_gemini_ai']:
            prompt = f"Ты играешь в мафию. Наступил день. Текст:\n{self._last_message}\nКого следует выгнать? Верни только ник (например: @username)."
            ai_response = await self._ask_gemini(prompt)
            if ai_response:
                target = ai_response.split()[0]

        if not target:
            target = self._extract_target_from_text(self._last_message) or ''

        cmd = self.config['vote_cmd'].format(target)
        await self._send_to_bot(cmd)
    except Exception as e:
        logger.exception('Day action failed: %s', e)

def _extract_target_from_text(self, text: str) -> str:
    if not text:
        return ''
    m = re.search(r"@([a-z0-9_]{5,})", text)
    if m:
        return '@' + m.group(1)
    m = re.search(r"(\d{5,20})", text)
    if m:
        return m.group(1)
    m = re.search(r"(?:vote|голос|голосует):?\s*([\w-]{3,})", text)
    if m:
        return m.group(1)
    return ''

async def _send_to_bot(self, text: str):
    if not text:
        return
    try:
        await self._client.send_message(self.config['bot'], text)
        logger.info('Sent to bot: %s', text)
    except Exception as e:
        logger.exception('Failed to send to bot: %s', e)

async def _main_loop(self):
    self._client.add_event_handler(self._message_handler, events.NewMessage(incoming=True))
    while self._running:
        await asyncio.sleep(1)
    try:
        self._client.remove_event_handler(self._message_handler)
    except Exception:
        pass

@loader.ratelimit
async def mafia_on(self, message):
    if self._running:
        await utils.answer(message, 'MafiaAutoAI уже запущен')
        return
    self._running = True
    self._task = asyncio.create_task(self._main_loop())
    await utils.answer(message, f'MafiaAutoAI запущен. Бот: {self.config["bot"]}')

@loader.ratelimit
async def mafia_off(self, message):
    if not self._running:
        await utils.answer(message, 'MafiaAutoAI не запущен')
        return
    self._running = False
    if self._task:
        self._task.cancel()
        self._task = None
    await utils.answer(message, 'MafiaAutoAI остановлен')

@loader.ratelimit
async def mafia_status(self, message):
    text = f"running: {self._running}\nrole: {self._role}\ngame_state: {self._game_state}\nAI: {self.config['ai_model']} (enabled={self.config['use_gemini_ai']})"
    await utils.answer(message, text)

