-- coding: utf-8 --

""" Hikka module: Mafia auto-player (best-effort) Author: Generated by ChatGPT

Описание: Этот модуль пытается автоматизировать игру в мафию в стороннем боте (по умолчанию @MafiaBakuBlackBot). Это шаблон: конкретные триггеры/команды бота могут отличаться — отредактируйте конфигурацию под поведение целевого бота.

ВАЖНО: использование автоматизации может нарушать правила бота/Telegram и привести к блокировке. Используйте на свой страх и риск. """

from .. import loader, utils import logging import asyncio import re

from telethon import events

logger = logging.getLogger(name)

@loader.tds class MafiaAutoMod(loader.Module): """Автоматическй игрок в мафию (шаблон)

Команды:
.mafia_on  - включить автопилот
.mafia_off - выключить
.mafia_status - показать состояние

Настройки модуля (можно менять):
- bot (username) — цельный бот для игры
- join_cmd, vote_cmd, night_cmd_pattern и т.д. — команды/шаблоны для взаимодействия
"""

strings = {"name": "MafiaAuto"}

def __init__(self):
    self._task = None
    self._running = False
    self._role = None
    self._game_state = "idle"
    self._last_message = None

    self.config = loader.ModuleConfig(
        "MafiaAutoConfig",
        [
            {
                "name": "bot",
                "type": str,
                "value": "@MafiaBakuBlackBot",
                "note": "Username of the mafia bot"
            },
            {
                "name": "join_cmd",
                "type": str,
                "value": "/join",
                "note": "Command to join game (edit to match bot)"
            },
            {
                "name": "start_cmd",
                "type": str,
                "value": "/start",
                "note": "Start command if required"
            },
            {
                "name": "vote_cmd",
                "type": str,
                "value": "/vote {}",
                "note": "Template to vote: use {} for nickname or id"
            },
            {
                "name": "night_action_cmd",
                "type": str,
                "value": "/kill {}",
                "note": "Template for night action (mafia)"
            },
            {
                "name": "detective_cmd",
                "type": str,
                "value": "/check {}",
                "note": "Template for detective check"
            },
            {
                "name": "doctor_cmd",
                "type": str,
                "value": "/save {}",
                "note": "Template for doctor save"
            },
            {
                "name": "auto_vote",
                "type": bool,
                "value": True,
                "note": "Автоматически голосовать при дневном этапе"
            },
            {
                "name": "random_seed",
                "type": int,
                "value": 0,
                "note": "Если 0 — используется системный выбор"
            },
            {
                "name": "message_patterns",
                "type": dict,
                "value": {
                    "role_mafia": ["mafia", "маф"],
                    "role_detective": ["detective", "детектив", "коп"],
                    "role_doctor": ["doctor", "доктор", "врач"],
                    "day_start": ["day", "День", "днём"],
                    "night_start": ["night", "Ночь", "ночью"],
                },
                "note": "Список ключевых слов для простого парсинга (добавьте варианты языка бота)"
            },
        ]
    )

async def client_ready(self, client, db):
    """Hikka lifecycle: client готов"""
    # клиент доступен как self.client или client
    self._client = client
    self._db = db

async def _message_handler(self, event: events.NewMessage.Event):
    """Обработчик сообщений от ботa: распознаём роли и этапы игры"""
    try:
        sender = await event.get_sender()
        if not sender:
            return
        if not hasattr(sender, 'username'):
            return
        if ('@' + (sender.username or '')).lower() != self.config['bot'].lower():
            return

        text = (event.message.message or '').lower()
        self._last_message = text

        # Простая логика поиска ролей
        patterns = self.config['message_patterns']

        if any(p in text for p in patterns.get('role_mafia', [])) and 'your role' in text or any(p in text for p in patterns.get('role_mafia', [])) and 'роль' in text:
            self._role = 'mafia'
            logger.info('Detected role: mafia')

        if any(p in text for p in patterns.get('role_detective', [])):
            self._role = 'detective'
            logger.info('Detected role: detective')

        if any(p in text for p in patterns.get('role_doctor', [])):
            self._role = 'doctor'
            logger.info('Detected role: doctor')

        # этапы
        if any(p in text for p in patterns.get('night_start', [])):
            self._game_state = 'night'
            logger.info('Game state: night')
            # триггер ночного действия
            asyncio.create_task(self._night_action())

        if any(p in text for p in patterns.get('day_start', [])):
            self._game_state = 'day'
            logger.info('Game state: day')
            if self.config['auto_vote']:
                asyncio.create_task(self._day_action())

    except Exception as e:
        logger.exception('Error in message handler: %s', e)

async def _night_action(self):
    """Ночной выбор — зависит от роли"""
    # небольшая задержка чтобы бот успел выслать список целей
    await asyncio.sleep(1.5)

    try:
        if self._role == 'mafia':
            # выбор цели: попытаемся извлечь ник из последнего сообщения (простой подход)
            target = self._extract_target_from_text(self._last_message) or ''
            cmd = self.config['night_action_cmd'].format(target)
            await self._send_to_bot(cmd)
        elif self._role == 'detective':
            target = self._extract_target_from_text(self._last_message) or ''
            cmd = self.config['detective_cmd'].format(target)
            await self._send_to_bot(cmd)
        elif self._role == 'doctor':
            # лечим самого себя по умолчанию
            me = (await self._client.get_me()).username or ''
            cmd = self.config['doctor_cmd'].format(me)
            await self._send_to_bot(cmd)
    except Exception as e:
        logger.exception('Night action failed: %s', e)

async def _day_action(self):
    """Действие днём — голосование (очень простая логика)"""
    await asyncio.sleep(1.0)
    try:
        # Попробуем найти кандидата для голосования в последнем сообщении
        candidate = self._extract_target_from_text(self._last_message) or ''
        if not candidate:
            # если не найдено — голосуем за случайное имя (будет пустой параметр)
            candidate = ''
        cmd = self.config['vote_cmd'].format(candidate)
        await self._send_to_bot(cmd)
    except Exception as e:
        logger.exception('Day action failed: %s', e)

def _extract_target_from_text(self, text: str) -> str:
    """Простейший экстрактор ника/id из текста. Отредактируйте для точного парсинга бота."""
    if not text:
        return ''
    # ищем @username
    m = re.search(r"@([a-z0-9_]{5,})", text)
    if m:
        return '@' + m.group(1)
    # ищем цифры (id)
    m = re.search(r"(\d{5,20})", text)
    if m:
        return m.group(1)
    # ищем строки вида "Vote: Nick" или "Голос: Nick"
    m = re.search(r"(?:vote|голос|голосует):?\s*([\w-]{3,})", text)
    if m:
        return m.group(1)
    return ''

async def _send_to_bot(self, text: str):
    """Отправляем сообщение боту и логируем"""
    if not text:
        return
    try:
        await self._client.send_message(self.config['bot'], text)
        logger.info('Sent to bot: %s', text)
    except Exception as e:
        logger.exception('Failed to send to bot: %s', e)

async def _main_loop(self):
    """Подключаем обработчик событий и ждём"""
    # добавить обработчик
    self._client.add_event_handler(self._message_handler, events.NewMessage(incoming=True))
    # держим таску живой
    while self._running:
        await asyncio.sleep(1)

    # удаляем обработчик при остановке
    try:
        self._client.remove_event_handler(self._message_handler)
    except Exception:
        pass

@loader.ratelimit
async def mafia_on(self, message):
    """Включить автопилот
    Использование: .mafia_on
    """
    if self._running:
        await utils.answer(message, 'MafiaAuto уже запущен')
        return
    self._running = True
    self._task = asyncio.create_task(self._main_loop())
    await utils.answer(message, 'MafiaAuto запущен. Отслеживание сообщений бота {}' .format(self.config['bot']))

@loader.ratelimit
async def mafia_off(self, message):
    """Отключить автопилот
    Использование: .mafia_off
    """
    if not self._running:
        await utils.answer(message, 'MafiaAuto не запущен')
        return
    self._running = False
    if self._task:
        self._task.cancel()
        self._task = None
    await utils.answer(message, 'MafiaAuto остановлен')

@loader.ratelimit
async def mafia_status(self, message):
    """Показать статус модуля"""
    text = 'running: {}\nrole: {}\ngame_state: {}\nbot: {}' .format(self._running, self._role, self._game_state, self.config['bot'])
    await utils.answer(message, text)

# aliases for commands (hikka-style)
mafia_on.__doc__ = "Включить: .mafia_on"
mafia_off.__doc__ = "Выключить: .mafia_off"
mafia_status.__doc__ = "Статус: .mafia_status"

End of module
